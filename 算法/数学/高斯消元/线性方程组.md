## 纯模拟
1. 找首元绝对值最大的行，防止系数过大影响精度
2. 交换到当前要处理的行
3. 首元化1
4. 首元所在列以下部分化0
5. 化为行阶梯后由下向上化行最简
```cpp
#include <iostream>
#include <iomanip>
#include <cmath>
using namespace std;
#define db double
#define cout2 cout<<fixed<<setprecision(2)
#define mn 1e-7
int n;
const int N = 110;
db a[N][N];
void input();
int gauss() {
	int c, r;
	for (c = 1, r = 1; c <= n; c++) {
		int pos = r;
        //找绝对值最大的首元，交换两行
		for (int i = r; i <= n; i++) {
			if (fabs(a[i][c]) > fabs(a[pos][c]))pos = i;
		}
        //若当前该列全为0，跳转至下一列
		if (fabs(a[pos][c]) < mn)continue;
        //交换
		for (int i = c; i <= n + 1; i++) {
			swap(a[r][i], a[pos][i]);
		}
        //首元化1
		for (int i = n + 1; i >= c; i--) {
			a[r][i] /= a[r][c];
		}
        //首元以下化0
		for (int i = r + 1; i <= n; i++) {
			if (fabs(a[i][c]) > mn)
				for (int j = n + 1; j >= c; j--) {
					a[i][j] -= a[i][c] * a[r][j];
				}
		}
		r++;
	}
    //判解
	if (r <= n) {
		for (int i = r; i <= n; i++) {
			if (fabs(a[i][n + 1]) > mn)return 2;
		}
		return 1;
	}
    //回代化最简行阶梯式
	for (int i = n; i >= 1; i--) {
		for (int j = i + 1; j <= n; j++) {
			a[i][n + 1] -= a[i][j] * a[j][n + 1];
		}
	}
	return 0;
}
signed main() {
	input();
	int t = gauss();
	if (t == 2) puts("No solution");
	else if (t == 1) puts("Infinite group solutions");
	else
	{
		for (int i = 1; i <= n; i++)
		{
			if (fabs(a[i][n + 1]) < mn) a[i][n + 1] = 0;
			cout2 << a[i][n + 1] << endl;
		}
	}

	return 0;

}
void input() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n + 1; j++) {
			cin >> a[i][j];
		}
	}
}
```
