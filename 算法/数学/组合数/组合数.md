# 组合数
---
### dp求组合数
### 状态转移方程$C_n^k=C_{n-1}^k+C_{n-1}^{k-1}$
```cpp
//dp预处理
#include <iostream>
using namespace std;
const int N = 2010;
const int mod = 1e9 + 7;
int c[N][N];
int init() {
	for (int i = 0; i < N; i++) {
		for (int j = 0; j <= i; j++) {
			if (!j)c[i][j] = 1;
			else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) %mod;
		}
	}
}
signed main() {
	int n;
	cin >> n;
	init();
	while (n--) {
		int a, b;
		cin >> a >> b;
		cout << c[a][b] << endl;
	}
	return 0;
}
```
---
### 逆元求组合数
```cpp
//预处理 阶乘与阶乘的逆元，将组合数公式中的除法变为乘法
#include <iostream>
using namespace std;
typedef long long ll;
const int N = 100010;
const int mod = 1e9 + 7;
ll fact[N];
ll infact[N];
ll fp(ll a, int n) {
	ll res = 1;
	while (n) {
		if (n & 1)res = a * res % mod;
		a = a * a % mod;
		n >>= 1;
	}
	return res;
}
void pre() {
	infact[0] = fact[0] = 1;
	for (int i = 1; i < N; i++) {
		fact[i] = fact[i - 1] * i % mod;
        //与阶乘相同，逆元也可以由前一个推出
		infact[i] = fp(i, mod - 2) * infact[i - 1] % mod;
	}
}
signed main() {
	 pre();
	int n;
	cin >> n;
	while (n--) {
		int a, b;
		cin >> a >> b;
		cout << fact[a] * infact[b] % mod * infact[a - b] % mod << endl;
	}
	return 0;
}
```

### lucas定理求组合数
[click](https://www.acwing.com/problem/content/889/)
```cpp
#include <iostream>
using namespace std;
typedef long long ll;
int p;
int fp(int a, int n) {
	int res = 1;
	while (n) {
		if (n & 1)res = (ll)res * a % p;
		a =(ll)a * a % p;
		n >>= 1;
	}
	return res;
}
int C(int a,int b) {
	if (b > a)return 0;
	int res = 1;
	for (int i = 1, j = a; i <= b; i++, j--) {
		res = (ll)res * j % p;
		res = (ll)res * fp(i, p - 2) % p;
	}
	return res;
}
int lucas(ll a, ll b) {
	if (a < p && b < p)return C(a, b);
	return (ll)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
signed main() {
	int n;
	cin >> n;
	while (n--) {
		ll a, b;
		cin >> a >> b >> p;
		cout << lucas(a, b)<<endl;
	}
	return 0;
}
```