# KMP  $O(m+n)$
[原题](https://www.acwing.com/problem/content/833/)
![图 5](../../images/a7d66bc08c046853f09dda15b51f63911dce3ab6ffffb6b10c308001c264d80d.png)  

> ### 引言 : 关于子串的前后缀

假设子串长度为i

前缀`P[1,j]` = 后缀`P[i-j+1,i]` 

前缀长度为`j`，那么后缀长度也是`j`,`i-j`（非后缀部分的末尾元素下标）再加1就是后缀起点

>对于kmp来说，我们要满足**前缀**等于**后缀**,这样每次匹配时，若匹配到某一个元素不等，此时前面的元素都相等，那么由于前缀等于后缀，我们只需要把字串挪到后缀起点重新开始匹配即可

>注意：我们要贪心的做，确保每种情况都能覆盖到，那么后缀的长度要达到尽可能地大，确保每次挪动步长最小。

>另外的，子串和源字符串下标从1开始，方便实现

---
### 关于next数组
>next 数组存的是：

当我的j+1不匹配的时候，`1~j`是匹配的, `1~j`此时是P的子串，找出`1~j`中最大的前缀和后缀相等,然后把整个P串挪到后缀的开头，再重新开始比较。
那么只需要把j变成j+1，即 前缀末尾的后一个元素再开始比较。
#### 那么next数组存储的就是每个P串子串`最大前缀长度`,即下次开始比较的位置-1

![图 2](../../images/fcedef47ee6f254d0fca1252313bad0b8a1e1f0cd4e77eebe0e02e89c79d6438.png)  

- next数组下标含义是，在下标之前（包含下标）这个范围取前后缀,我只需要保证这个范围内我的前缀等于后缀就可以
---
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long  
const int N = 1e6;
int n, m;
char p[N], s[N];
int ne[N]={0};
signed main(void) {
	cin >> n >> p + 1 >> m >> s + 1;
	//求next数组,其实就是用kmp的模式将P串分成若干段子串匹配它本身
	//错开一位开始求，因P串一定等于它本身。
	for (int i = 2, j = 0; i <= n; i++) {
		//每次求1~i这段子串的next
		//若匹配不成功，则调用上个已经求出来的next，进行平移，挪后能保证1~i-1前缀后缀是相等的，然后尝试匹配p[i] 和 p[j+1]
		//因为每次总是调用的上一个next，所以能保证前缀后缀长度最大,因为上一个next也保证了长度最大。
		//当j为0的时候，退无可退。
		while (j && p[i] != p[j + 1])j = ne[j];//ne[j] <j
		if (p[i] == p[j + 1])j++;
		ne[i] = j;
	}
	//和s[i] 匹配的永远是 p[j+1] 方便实现当匹配失败时，j就是最后一个匹配成功的元素，此时next直接写成next[j]即可。
	for (int i = 1, j = 0; i <= m; i++) {
		//当j为0的时候，退无可退。
		while (j && s[i] != p[j + 1])j = ne[j];
		//如果匹配，则继续下一位
		if (s[i] == p[j + 1])j++;
		if (j == n) {
			//匹配成功
			cout << i - n<<' ';
			//若匹配成功，接着求。
			j = ne[j];
		}
	}


}

```

---

这里分析下[n,2n]的最坏情况是怎么得出的，可以抽象下这样理解，遍历待匹配字符串strN时，比较S[i]、P[j]时可能的情况为：
1. 当前字符匹配时，同时移动 i++，j++
2. 当前字符不匹配，且j=0时，只移动 i++，j=0不动
3. 当前字符不匹配，且j!=0时，i不变，P[j]回跳，最多跳j次，但j由前面匹配的情况1确定，而情况1总共不可能出现超过n次，所以总回跳不会超过n次
所以最坏情况，i++次数（情况一+情况二）+ j回跳（情况3）= n + 最坏n = 2n
